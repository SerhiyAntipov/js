Строгий режим
"use strict".

Переменные
Можно объявить при помощи:
•	let
•	const (константа, те изменению не подлежит)
•	var (устаревший способ, подробности позже)
Имя переменной может включать:
•	Буквы и цифры, однако цифра не может быть первым символом.
•	Символы $ и _ используются наряду с буквами.
•	Иероглифы и символы нелатинского алфавита также допустимы, но обычно не используются
Переменные типизируются динамически
В них могут храниться любые значения.


Типы данных
В JavaScript есть 8 основных типов.
•	number для любых чисел: целочисленных или чисел с плавающей точкой, целочисленные значения ограничены диапазоном ±253.
•	bigint для целых чисел произвольной длины.
•	string для строк. Строка может содержать один или больше символов, нет отдельного символьного типа.
•	boolean для true/false.
•	null для неизвестных значений – отдельный тип, имеющий одно значение null.
•	undefined для неприсвоенных значений – отдельный тип, имеющий одно значение undefined.
•	object для более сложных структур данных.
•	symbol для уникальных идентификаторов.

1. number - числовой тип данных Infinity, -Infinity и NaN. - специальные числовые значения»
2. BigInt
В JavaScript тип «number» не может содержать числа больше, чем 253 (или меньше, чем -253 для отрицательных)
Это техническое ограничение вызвано их внутренним представлением. 253 – это достаточно большое число, состоящее из 16 цифр, поэтому чаще всего проблем не возникает. Но иногда нам нужны действительно гигантские числа, например в криптографии или при использовании метки времени («timestamp») с микросекундами
Тип BigInt был добавлен в JavaScript, чтобы дать возможность работать с целыми числами произвольной длины
Чтобы создать значение типа BigInt, необходимо добавить n в конец числового литерала:
символ "n" в конце означает, что это BigInt
const bigInt = 1234567890123456789012345678901234567890n;
3. string – строка
4. boolean  Булевый тип может принимать только два значения: true (истина) и false
5.  null  Специальное значение null не относится ни к одному из типов, описанных выше
Оно формирует отдельный тип, который содержит только значение null
В JavaScript null не является «ссылкой на несуществующий объект» или «нулевым указателем», как в некоторых других языках
Это просто специальное значение, которое представляет собой «ничего», «пусто» или «значение неизвестно».
6.  undefined  Специальное значение undefined также стоит особняком. Оно формирует тип из самого себя так же, как и null
Оно означает, что «значение не было присвоено»
Если переменная объявлена, но ей не присвоено никакого значения, то её значением будет undefined:
7. object (объект) – особенный
Все остальные типы называются «примитивными», потому что их значениями могут быть только простые значения (будь то строка или число, или что-то ещё). Объекты же используются для хранения коллекций данных или более сложных объектов. 


Преобразования
Существует 3 наиболее широко используемых й: строковое, численное и логическое.
Строковое – Происходит, когда нам нужно что-то вывести. Может быть вызвано с помощью String(value). Для примитивных значений работает очевидным образом.
Численное – Происходит в математических операциях. Может быть вызвано с помощью Number(value).
Подчиняется правилам:
Значение	Становится…
undefined	NaN
null	0
true / false	1 / 0
string	Пробельные символы по краям обрезаются. Далее, если остаётся пустая строка, то 0, иначе из непустой строки «считывается» число. При ошибке результат NaN.

Логическое – Происходит в логических операторах. Может быть вызвано с помощью Boolean(value).
Подчиняется правилам:
Значение	Становится…
0, null, undefined, NaN, ""	 - false
любое другое значение	true

•	undefined при численном преобразовании становится NaN, не 0.
•	"0" и строки из одних пробелов типа " " при логическом преобразовании всегда true.


Взаимодействие: alert, prompt, confirm.
Функция prompt принимает два аргумента
result = prompt(title, [default]);
Вызов prompt вернёт текст, указанный в поле для ввода, или null, если ввод отменён пользователем.
Например
let age = prompt('Сколько тебе лет?', 100);
alert(`Тебе ${age} лет!`); // Тебе 100 лет!

Функция confirm отображает модальное окно с текстом вопроса question и двумя кнопками: OK и Отмена.
Результат true, если нажата кнопка OK. В других случаях – false.
Например:
let isBoss = confirm("Ты здесь главный?");
alert( isBoss ); // true, если нажата OK


Операторы
JavaScript поддерживает следующие операторы:
Арифметические
Простые * + - /, а также деление по модулю % и возведение в степень **.
Бинарный плюс + объединяет строки. А если одним из операндов является строка, то второй тоже будет конвертирован в строку:
alert( '1' + 2 ); // '12', строка
alert( 1 + '2' ); // '12', строка
Операторы присваивания
Простые a = b и составные a *= 2.
Битовые операции
Битовые операторы работают с 32-битными целыми числами на самом низком, побитовом


Оператор «if» 
Условный оператор „?“
Оператор представлен знаком вопроса ?. Его также называют «тернарный», так как этот оператор, единственный в своём роде, имеет три аргумента.
Синтаксис:
let result = условие ? значение1 : значение2;
Сначала вычисляется условие: если оно истинно, тогда возвращается значение1, в противном случае – значение2.
Например:
let accessAllowed = (age > 18) ? true : false;

Логические операторы
Логические И &&, ИЛИ || используют так называемое «ленивое вычисление» и возвращают значение, на котором оно остановилось (не обязательно true или false). Логическое НЕТ ! конвертирует операнд в логический тип и возвращает инвертированное значение.

Сравнение
Проверка на равенство == значений разных типов конвертирует их в число (за исключением null и undefined, которые могут равняться только друг другу), так что примеры ниже равны:
alert( 0 == false ); // true
alert( 0 == '' ); // true

Оператор строгого равенства === не выполняет конвертирования: разные типы для него всегда означают разные значения.
Значения null и undefined особенные: они равны == только друг другу, но не равны ничему ещё.


Циклы while и for
let i = 0;
while (i < 3) { // выводит 0, затем 1, затем 2
  alert( i );
  i++;
}
let i = 3;
while (i) { // когда i будет равно 0, условие станет ложным, и цикл остановится
  alert( i );
  i--;
}

Прерывание цикла: «break»
Директива break в строке (*) полностью прекращает выполнение цикла и передаёт управление на строку за его телом

Переход к следующей итерации: continue
Директива continue – «облегчённая версия» break. При её выполнении цикл не прерывается, а переходит к следующей итерации (если условие все ещё равно true).

Конструкция switch 
Конструкция switch заменяет собой сразу несколько if.
Она представляет собой более наглядный способ сравнить выражение сразу с несколькими вариантами.
Синтаксис
Конструкция switch имеет один или более блок case и необязательный 
let a = 2 + 2;

switch (a) {
  case 3:
    alert( 'Маловато' );
  case 4:
    alert( 'В точку!' );
  case 5:
    alert( 'Перебор' );
  default:
    alert( "Нет таких значений" );
}


Функции
Три способа создания функции в JavaScript:

1.	Function Declaration: функция в основном потоке кода
2.	function sum(a, b) {
3.	  let result = a + b;
5.	  return result;
}

6.	Function Expression: функция как часть выражения
7.	let sum = function(a, b) {
8.	  let result = a + b;
10.	  return result;
};

11.	Стрелочные функции:
13.	let sum = (a, b) => a + b;
14.	
15.	// многострочный код в фигурных скобках { ... }, здесь нужен return:
16.	let sum = (a, b) => {
17.	  // ...
18.	  return a + b;
19.	}
20.	
21.	// без аргументов
22.	let sayHi = () => alert("Привет");
23.	
24.	// с одним аргументом
let double = n => n * 2;

У функций могут быть локальные переменные: те объявленные в теле функции
Такие переменные видимы только внутри функции
У параметров могут быть значения по умолчанию: function sum(a = 1, b = 2) {...}.
Функции всегда что-нибудь возвращают. Если нет оператора return, результатом будет undefined.

Замикання
Для того чтобы понять замыкания, нам нужно разобраться с двумя важнейшими концепциями JavaScript. 
Контекст выполнения (Execution Context).
Лексическое окружение (Lexical Environment).

function getCounter() {
  let counter = 0;
  return function() {
    return counter++;
  }
}
let count = getCounter();
console.log(count());  // 0
console.log(count());  // 1
console.log(count());  // 2

Мы храним ссылку на анонимную внутреннюю функцию, возвращённую функцией getCounter(), в переменной count. 
Так как функция count() представляет собой замыкание, она может обращаться к переменной counter функции getCount() даже после того, как функция getCounter() завершила работу.
Обратите внимание на то, что значение переменной counter не сбрасывается в 0 при каждом вызове функции count(). 
Может показаться, что оно должно сбрасываться в 0, как могло бы быть при вызове обычной функции, но этого не происходит.
Всё работает именно так из-за того, что при каждом вызове функции count() для неё создаётся новая область видимости, но существует лишь одна область видимости для функции getCounter(). 
Так как переменная counter объявлена в области видимости функции getCounter(), её значение между вызовами функции count() сохраняется, не сбрасываясь в 0.

// map array
let array4 = [1, 24, 20, 21, 2, 36, 33, 3, 30];
let newArray4 = array4.map(function (data, i, object) {
    return data * 3;
})

// filter array
let newArray5 = array4.filter(function (data, i, object) {
    if ((data % 2) == 0) return true
})

// split -- string to array
let string = 'hello,my,name,alla'
console.log(string.split(','))
["hello", "my", "name", "alla"]


// join -- array to string
array4 = [1, 24, 20, 21, 2, 36, 33, 3, 30];
console.log(array4. join())


// stringify --
let string2 = JSON.stringify([1, 3, 6, 9])

// parse --
console.log(JSON.parse(string2))

// sort ======================
// 1 --
let array1 = [1, 38, 35, 2, 29, 26, 45, 3, 18];
array1.sort(compare);

function compare(a, b) {
    return a - b;
}

// 2 --
let array2 = [1, 24, 20, 21, 2, 36, 33, 3, 30];
array2.sort((a, b) => a - b);

// 3 --
let array3 = [{
        name: 'Alex',
        price: 1500
    },
    {
        name: 'Bob',
        price: 900
    },
    {
        name: 'Jain',
        price: 1300
    }
];
array3.sort((a, b) => a.price - b.price);

// 4 sort reverse --
array4 = [1, 24, 20, 21, 2, 36, 33, 3, 30];
array4.sort((a, b) => a - b).reverse();

// push add last element
array4.push(27);

// pop del last element
array4.pop();

// shift del 0 element 
array4.shift()

// unshift add 0 element 
array4.unshift(0)

// splice element--
array4.splice(3, 2)

// splice element & add data--
array4.splice(3, 2, 'add-data')

// for(let i = 0; i < array1.length; i++)
let array5 = [1, 4, 7, 78, 90, 34, 45];
for (let i = 0; i < array5.length; i++) {
    // console.log(array5[i])
}

// while
array5 = [1, 4, 7, 78, 90, 34, 45];
let p = 0;
while (p < array5.length) {
    // console.log(array5[p])
    p++
}

// for (let key in newArray4) 
let array6 = {
    'data': 123,
    'asd': 345,
    'fgh jk': 67879,
    'ghjkg': 'ghgjh',
}
for (let key in array6) {
    console.log(key)
    console.log(array6[key])
}

// for (let item of array7) nodelist HTML collection !!!
array7 = [1, 4, 7, 78, 90, 34, 45];
for (let item of array7) {
    // console.log(item)
}

// forEach --
array7.forEach(function (data, i, object) {
    // console.log(data)
})

// set ----
let defaultCity = ['lviv']
let dataCitySet = new Set(defaultCity);
let nameCity = 'Brody'
dataCitySet.add(nameCity.toLowerCase())
// console.log(dataCitySet)
// console.log(Array.from(dataCitySet))

// xhttpRequesrt =========================
xhttpRequesrtWeather()

function xhttpRequesrtWeather() {
    let xhttp = new XMLHttpRequest();
    xhttp.onreadystatechange = function () {
        if (this.readyState == 4 && this.status == 200) {
            let response = JSON.parse(this.response);
            console.log(response)
        }
    };
    xhttp.open('GET', `http://api.openweathermap.org/data/2.5/weather?q=lviv&appid=0bf66710f118cd8dbd8d4055849f69aa`, true);
    xhttp.send();
};

// fetch  ====================
fetchWeatherHour()

function fetchWeatherHour() {
    fetch(`http://api.openweathermap.org/data/2.5/forecast?id=702550&appid=0bf66710f118cd8dbd8d4055849f69aa`)
        .then(function (response) {
            return response.json()
        })
        .then(function (response) {
            weatherHour = response;
            console.log(weatherHour)
        })
        .catch(function () {
            console.log('the database did not load')
        });
}

